#!/usr/bin/env python
from __future__ import with_statement

import logging
import sys
import datetime
import optparse
import signal
import os
import gc
import errno

from twisted.python import log
from twisted.internet import reactor, defer
from twisted.web import server

from tron import mcp, cmd, job, resource, node, scheduler, www, monitor, emailer, config

logger = logging.getLogger('bin.trond')

def create_default_config(config_path):
    """Create a default empty configuration for first time installs"""
    with open(config_path, "w") as config_file:
        config_file.write(config.DEFAULT_CONFIG)

def parse_options():
    parser = optparse.OptionParser()

    parser.add_option("--working-dir", action="store", dest="working_dir", help="Directory where tron's state and output is stored (default %default)", default="/var/lib/tron/")
    parser.add_option("--log-file", "-l", action="store", dest="log_file", help="Where the logs are stored (default %default)", default="/var/log/tron.log")
    parser.add_option("--config-file", "-c", action="store", dest="config_file", help="Configuration file to load (default in working dir)", default=None)

    parser.add_option("--verbose", "-v", action="count", dest="verbose", help="Verbose logging", default=0)
    parser.add_option("--debug", action="store_true", dest="debug", help="Debug mode, extra error reporting")

    parser.add_option("--port", "-P", action="store", dest="listen_port", help="What port to listen on, defaults %default", default=cmd.DEFAULT_PORT, type=int)
    parser.add_option("--host", "-H", action="store", dest="listen_host", help="What host to listen on defaults to %default", default=cmd.DEFAULT_HOST, type=str)
    
    (options, args) = parser.parse_args(sys.argv)
    
    if not options.working_dir:
        parser.error("Bad working-dir option")

    if options.config_file is None:
        options.config_file = os.path.join(options.working_dir, "tron_config.yaml")
    
    
    return options

def setup_logging(options):
    level = logging.WARNING
    stream = sys.stderr
    if options.verbose > 0:
        stream = sys.stdout
        level = logging.INFO
    if options.verbose > 1:
        level = logging.DEBUG

    try:
        logging.basicConfig(level=level,
                            format='%(asctime)s %(name)s %(levelname)s %(message)s',
                            stream=stream, 
                            filename=options.log_file)
    except IOError, e:
        print >>sys.stderr, e
        sys.exit()

    # Hookup twisted to standard logging
    observer = log.PythonLoggingObserver()
    observer.start()

    # Show stack traces for errors in twisted deferreds.
    if options.debug:
        defer.setDebugging(True)

def main():
    options = parse_options()
    
    setup_logging(options)
    
    # Setup our environment
    try:
        os.makedirs(options.working_dir)
    except OSError, e:
        if e.errno == errno.EEXIST:
            pass
        else:
            raise
    
    if not os.path.isdir(options.working_dir) or not os.access(options.working_dir, os.R_OK|os.R_OK|os.X_OK):
        print >>sys.stderr, "Error, working directory %s invalid" % (options.working_dir)
        sys.exit(1)

    # See if we can access or create the config file
    if not os.path.exists(options.config_file):
        try:
            create_default_config(options.config_file)
        except OSError, create_e:
            print >>sys.stderr, "Error creating default configuration at %s: %r" % (options.config_file, create_e)
            sys.exit(1)

    if not os.access(options.config_file, os.R_OK|os.W_OK):
        print >>sys.stderr, "Error opening configuration %s: %r" % (options.config_file, create_e)
        sys.exit(1)

    # Build and configure the mcp
    master_control = mcp.MasterControlProgram(options.working_dir, options.config_file)
    try:
        master_control.load_config()
    except Exception, e:
        print >>sys.stderr, "Error in configuration file:", e
        sys.exit(1)
    
    # Try to load up previous state
    master_control.try_restore()
    
    # Setup our reconfiguration signal handler
    def sighup_handler(signum, frame):
        logger.info("SIGHUP Caught!")
        reactor.callLater(0, master_control.live_reconfig)
        # TODO: Reopen log files
        #  It's strange that the logging module doesn't seem to have a built-in system for re-opening logs
        #  on SIGHUP even though that's a pretty normal thing to do. There is functionality for handling the rotating
        #  directly, but that's.... sorta lame.

    signal.signal(signal.SIGHUP, sighup_handler)

    # Start up our web management interface
    reactor.listenTCP(options.listen_port, server.Site(www.RootResource(master_control)), interface=options.listen_host)

    # Setup the mcp timed callbacks
    reactor.callLater(0, master_control.run_jobs)
    
    # and then off to reactor land...
    reactor.run()

if __name__ == '__main__':
    main()
