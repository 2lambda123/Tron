#!/usr/bin/env python
from __future__ import with_statement
import logging
import os
import shutil
import tempfile
import traceback
import sys

from tron.commands import cmd_utils
from tron.commands.client import Client
from tron.config import config_parse
from tron.config import schema, manager, ConfigError


log = logging.getLogger('tronfig')


def parse_options():
    usage  = "usage: %prog [options] [<name>] [-|path]"
    parser = cmd_utils.build_option_parser(usage)

    parser.add_option("-p", "--print", action="store_true", dest="print_config",
                      help="Print config to stdout, rather than uploading")
    parser.add_option("-C", "--check", action="store_true", dest="check",
                      help="Upload and check configuration, don't apply, "
                           "useful when you want to verify if tron daemon "
                           "will accept your configuration.")
    parser.add_option("-d", "--delete", action="store_true",
                      help="Delete the configuration for this namespace")
    parser.add_option("-V", "--validate", action="store_true", dest="validate",
                      help="Only validate configuration, don't upload, "
                           "useful for verifying config locally. If namespace "
                           "is not specified, it will be derived from file "
                           "name, if any.")
    parser.add_option("-D", "--validate-dir",
                      action="store",
                      dest="validate_dir",
                      help="Full validation of a folder, don't upload, "
                           "same as -V but checks for more edge-cases")

    return parser.parse_args()


def upload_config(client, config_name, contents, config_hash, check=False):
    response = client.config(
        config_name,
        config_data=contents,
        config_hash=config_hash,
        check=check
    )

    if 'error' in response:
        log.error(response['error'])
        return False

    print >>sys.stderr, "Configuration uploaded successfully"
    return True


def validate(config_name, config_content):
    try:
        config_data = manager.from_string(config_content)
        config_parse.validate_fragment(config_name, config_data)
    except ConfigError, e:
        return str(e)


def delete_config(client, config_name):
    if config_name == schema.MASTER_NAMESPACE:
        log.error("Deleting MASTER namespace is not allowed. Name must be specified.")
        return

    response = raw_input(
        "This will delete the configuration for the %s namespace. Proceed? (y/n): " % config_name)
    if response[:1].lower() != 'y':
        return

    config_hash = client.config(config_name)['hash']
    if upload_config(client, config_name, "", config_hash):
        return
    raise SystemExit("tronfig deletion failed")


def validate_dir(path):
    try:
        manifest_dir = tempfile.mkdtemp()
        manifest = manager.ManifestFile(manifest_dir)
        manifest.create()
        for fname in os.listdir(path):
            if fname.endswith(".yaml"):
                namespace = fname[0:-5]
                manifest.add(namespace, os.path.join(path, fname))

        config_manager = manager.ConfigManager(path, manifest)
        config_manager.load()
    except ConfigError, e:
        traceback.print_exc()
        return str(e)
    finally:
        if manifest_dir:
            shutil.rmtree(manifest_dir)


def get_config_input(namespace, source=None):
    if source is None:
        source = namespace

    if source == '-':
        source_io = sys.stdin
        namespace = schema.MASTER_NAMESPACE
    else:
        source_io = open(source, 'r')
        namespace = os.path.basename(source)[0:-5]

    content = source_io.read()

    return namespace, content, source


if __name__ == '__main__':
    options, args = parse_options()
    cmd_utils.setup_logging(options)
    cmd_utils.load_config(options)

    if options.validate or options.validate_dir:
        if options.validate:
            name, content, source = get_config_input(*args)
            result = validate(name, content)
        elif options.validate_dir is not None:
            result = validate_dir(options.validate_dir)

        if not result:
            print "OK"
            sys.exit(0)
        else:
            print result
            sys.exit(1)

    client = Client(options.server)

    if options.print_config:
        name, content = get_config_input(*args)
        print client.config(config_name)['config']
    elif options.delete:
        name = args[0]
        delete_config(client, config_name)
    else:
        name, content = get_config_input(*args)
        config_hash = client.config(name)['hash']

        result = validate(name, content)
        if result:
            print result
            sys.exit(1)

        if upload_config(
                client, name, content, config_hash, check=check):
            sys.exit(0)

        print "Uploading failed"
        sys.exit(1)
