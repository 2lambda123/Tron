from testify import *
from testify.test_case import TwistedFailureError
from twisted.internet import reactor, defer
from twisted.python import failure



_waiting = False
def wait_for_deferred(deferred):
    """Wait for the deferred object to complete
    
    Loosly based on twisted trial test case base, allows us to run reactors in a test case
    """
    
    global _waiting
    if _waiting:
        raise RuntimeError("_wait is not reentrant")
    _waiting = True

    results = []
    failures = []
    def append(any):
        if results is not None:
            results.append(any)
    def crash(ign):
        if results is not None:
            reactor.crash()

    def stop():
        reactor.crash()

    def on_failure(f):
        failures.append(f)

    deferred.addErrback(on_failure)

    try:
        deferred.addBoth(append)
        if results:
            # d might have already been fired, in which case append is
            # called synchronously. Avoid any reactor stuff.
            return
        deferred.addBoth(crash)
        reactor.stop = stop
        try:
            reactor.run()
        finally:
            del reactor.stop

    finally:
        _waiting = False
        results = None
        if failures:
            failure = failures[0]
            # By this point we've already lost too much of our exception information (traceback, stack)
            # to re-create the real exception. So what we'll have to do is hope our test framework can
            # handle twisted failure objects so we can get some useful information out of them.
            raise TwistedFailureError(failure)
            #raise failure.type, failure.value, failure.getTracebackObject()
            #failures[0].raiseException()

    
DEFAULT_TIMEOUT = 10.0

def run_reactor(timeout=DEFAULT_TIMEOUT, assert_raises=None):
    """Decorator generator for the fixture decorators
    
    Args -
        timeout - (optional) number of seconds to wait for defer to finish up
        assert_raises - (optional) exception that should be generated by deferred
    """

    def wrapper(method):
        def on_timeout(d):
            e = defer.TimeoutError("(%s) still running at %s secs" % (method.__name__, timeout))
            f = failure.Failure(e)

            try:
                d.errback(f)
            except defer.AlreadyCalledError:
                # if the deferred has been called already but the *back chain
                # is still unfinished, crash the reactor and report timeout
                # error ourself.
                reactor.crash()
                raise

        def run_defer(*args, **kwargs):
            deferred = defer.maybeDeferred(method, *args, **kwargs)

            call = reactor.callLater(timeout, on_timeout, deferred)
            deferred.addBoth(lambda x : call.active() and call.cancel() or x)
            
            found_error = False
            try:
                result = wait_for_deferred(deferred)
            except TwistedFailureError, e:
                if assert_raises:
                    d_fail = e.args[0]
                    if issubclass(d_fail.type, assert_raises):
                        found_error = True
                else:
                    raise
                    
            if assert_raises and not found_error:
                assert_not_reached("No exception was raised (expected %s)" % assert_raises)
        
            return None
        return run_defer
    return wrapper