#!/usr/bin/env python
"""This process is spawned by trond in order to offload state save/load
operations such that trond can focus on the more important things without
blocking for large chunks of time. It takes command line arguments (the order
of which is specifically hardcoded) in order to configure itself and use
the correct methods for state saving and message transport with trond.

Messages are sent via stdin/out, as the twisted framework that provides
management of child processes uses it for communication. Because the core
Python stdin reader is blocking, a separate thread is spawned in tronstore
to buffer all messages that come via stdin.

The process gracefully shuts down whenever it recieves a SIGINT by first
processing all requests it has already read from stdin. trond capitalizes on
this behavior by propagating any SIGINT signals it receives to tronstore.
"""
import sys
import os
import signal
import time
from threading import Thread
from Queue import Queue, Empty

from tron.serialize.runstate.tronstore.messages import StoreRequestFactory, StoreResponseFactory
from tron.serialize.runstate.tronstore import store
from tron.serialize.runstate.tronstore import msg_enums
from tron.serialize.runstate.tronstore.chunking import StoreChunkHandler

is_shutdown = False

def shutdown_handler(signum, frame):
    """Signal the process to shut down, finishing any requests it already had."""
    global is_shutdown
    is_shutdown = True

def parse_args():
    """Parse the command line arguments. THIS MUST MATCH THE ORDER GIVEN BY
    parallelstore.py when it initializes the tronstore process.
    """
    name = sys.argv[1]
    transport_method = sys.argv[2]
    store_type = sys.argv[3]
    connection_details = sys.argv[4]
    db_store_method = sys.argv[5]

    return (transport_method, store.build_store(name, store_type, connection_details, db_store_method))

def enqueue_input(stdin, queue):
    """Enqueue anything read by stdin into a queue. This is run in a separate
    thread such that requests can be processed without blocking."""
    try:
        for line in stdin:
            queue.put(line)
        stdin.close()
    except Exception, e:  # something happened, finish up and exit
        stdin.close()
        global is_shutdown
        is_shutdown = True

def start_stdin_thread():
    """Starts the thread that will enqueue all stdin data into the stdin_queue."""
    stdin_queue = Queue()
    stdin_thread = Thread(target=enqueue_input, args=(sys.stdin, stdin_queue))
    stdin_thread.daemon = True
    stdin_thread.start()
    return stdin_queue

def get_all_from_queue(queue):
    """Gets all of the requests from the stdin_queue, returning one long string."""
    tmp_str = ''
    while not queue.empty():
        try:
            tmp_str += queue.get_nowait()
        except Empty:
            break
    return tmp_str

def handle_request(request, store_class):
    """Handle a request by acting on store_class with the appropriate action."""
    if request.req_type == msg_enums.REQUEST_SAVE:
        success = store_class.save(request.data[0], request.data[1], request.data_type)
        return (success, request.id, '')
    elif request.req_type == msg_enums.REQUEST_RESTORE:
        success, data = store_class.restore(request.data, request.data_type)
        return (success, request.id, data)
    else:
        return (False, request.id, '')

def main():
    """The main run loop for tronstore. This loop sets up everything
    based on the command line arguments tronstore got, and then simply
    waits for requests to handle from stdin, and writes responses to
    stdout. The process will run until an error or SIGINT occurs."""
    (transport_method, store_class) = parse_args()
    request_factory = StoreRequestFactory(transport_method)
    response_factory = StoreResponseFactory(transport_method)
    chunk_handler = StoreChunkHandler()
    stdin_queue = start_stdin_thread()

    global is_shutdown
    signal.signal(signal.SIGINT, shutdown_handler)

    while True:
        if is_shutdown:
            if stdin_queue.empty():
                time.sleep(0.5)
                if stdin_queue.empty():
                    store_class.cleanup()
                    return

        requests = chunk_handler.handle(get_all_from_queue(stdin_queue))
        requests = map(request_factory.rebuild, requests)
        for request in requests:
            request = request_factory.rebuild(request)
            response = handle_request(request, store_class)
            response = response_factory.build(response[0], response[1], response[2])
            sys.stdout.write(chunk_handler.sign(response.serialized))


if __name__ == '__main__':
    main()
